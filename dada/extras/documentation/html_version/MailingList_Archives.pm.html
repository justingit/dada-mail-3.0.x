<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DADA::MailingList::Archives</title>
<link rel="stylesheet" href="/Users/justin/Documents/DadaMail/build/tmp/dada/extras/documentation/pod_source/pod_styles.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@omen.apple.com" />
</head>

<body>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#methods">METHODS</a></li>
	<ul>

		<li><a href="#get_neighbors">get_neighbors</a></li>
		<li><a href="#check_if_entry_exists_">check_if_entry_exists;</a></li>
		<li><a href="#set_archive_subject___">set_archive_subject();</a></li>
		<li><a href="#set_archive_message___">set_archive_message();</a></li>
		<li><a href="#set_archive_format">set_archive_format</a></li>
		<li><a href="#get_archive_subject">get_archive_subject</a></li>
		<li><a href="#get_archive_format">get_archive_format</a></li>
		<li><a href="#get_archive_message">get_archive_message</a></li>
		<li><a href="#create_index">create_index</a></li>
		<li><a href="#newest_entry">newest_entry</a></li>
		<li><a href="#oldest_entry">oldest_entry</a></li>
		<li><a href="#create_index_nav">create_index_nav</a></li>
		<li><a href="#make_nav_table_">make_nav_table,</a></li>
		<li><a href="#make_search_form">make_search_form</a></li>
		<li><a href="#_zap_sig_plaintext">_zap_sig_plaintext</a></li>
		<li><a href="#_zap_sig_html">_zap_sig_html</a></li>
		<li><a href="#massage">massage</a></li>
		<li><a href="#make_search_summary">make_search_summary</a></li>
		<li><a href="#_faked_oldstyle_message">_faked_oldstyle_message</a></li>
		<li><a href="#message_blurb">message_blurb</a></li>
		<li><a href="#massage_msg_for_resending">massage_msg_for_resending</a></li>
		<li><a href="#_take_off_sigs">_take_off_sigs</a></li>
		<li><a href="#massaged_msg_for_display">massaged_msg_for_display</a></li>
		<li><a href="#_chomp_off_body">_chomp_off_body</a></li>
		<li><a href="#_add_a_body_if_needed">_add_a_body_if_needed</a></li>
		<li><a href="#_get_body_entity">_get_body_entity</a></li>
		<li><a href="#_bs_raw_msg">_bs_raw_msg</a></li>
		<li><a href="#w3cdtf">W3CDTF</a></li>
		<li><a href="#atom_index">atom_index</a></li>
		<li><a href="#rss_index">rss_index</a></li>
		<li><a href="#send_pings">send_pings</a></li>
		<li><a href="#_massaged_key">_massaged_key</a></li>
	</ul>

	<li><a href="#copyright">COPYRIGHT </a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>DADA::MailingList::Archives</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This module holds the shared methods between the different archive backends</p>
<p>Many of these methods have to do with massaging the message for viewing;</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<p>
</p>
<h2><a name="get_neighbors">get_neighbors</a></h2>
<pre>
        my ($prev, $next) = $archive-&gt;get_neighbors();</pre>
<p>this will tell you in the frame of reference of what message you're on, 
what the previous and next entry keys are.</p>
<p>
</p>
<h2><a name="check_if_entry_exists_">check_if_entry_exists;</a></h2>
<p>see if an entry exists, returns 1 when its there, 0 if it aint</p>
<p>
</p>
<h2><a name="set_archive_subject___">set_archive_subject();</a></h2>
<p>$archive-&gt;set_archive_subject($subject);</p>
<p>changes the archive's subject</p>
<p>
</p>
<h2><a name="set_archive_message___">set_archive_message();</a></h2>
<pre>
        $archive-&gt;set_archive_message($message);</pre>
<p>changes the archive's message (yo)</p>
<p>
</p>
<h2><a name="set_archive_format">set_archive_format</a></h2>
<pre>
        $archive -&gt; set_archive_format($format);</pre>
<p>changes the archive's format (yo)</p>
<p>
</p>
<h2><a name="get_archive_subject">get_archive_subject</a></h2>
<pre>
        my $format = get_archive_subject($key);</pre>
<p>gets the subject of the given $key</p>
<p>
</p>
<h2><a name="get_archive_format">get_archive_format</a></h2>
<pre>
        my $format = get_archive_format($key);</pre>
<p>gets the format of the given $key</p>
<p>
</p>
<h2><a name="get_archive_message">get_archive_message</a></h2>
<pre>
        my $format = get_archive_message($key);</pre>
<p>gets the message of the given $key</p>
<p>
</p>
<h2><a name="create_index">create_index</a></h2>
<pre>
        my ($begin, $stop) = $archive-&gt;create_index($start);</pre>
<p>This 'll tell you what to print on each archive index. 
something like, 'start on the 40th message and end on the 50th'</p>
<p>
</p>
<h2><a name="newest_entry">newest_entry</a></h2>
<p>returns the the key/id of the most recent archive message</p>
<p>
</p>
<h2><a name="oldest_entry">oldest_entry</a></h2>
<p>returns the key/of the first archive message</p>
<p>
</p>
<h2><a name="create_index_nav">create_index_nav</a></h2>
<pre>
        print $archive-&gt;create_index_nav($stopped_at);</pre>
<p>creates a HTML table that looks like this:</p>
<pre>
            &lt;&lt;Prev                      Next &gt;&gt;</pre>
<p>at the bottom of each archive index</p>
<p>
</p>
<h2><a name="make_nav_table_">make_nav_table,</a></h2>
<pre>
        print $archive -&gt; make_nav_table(-Id =&gt; $id, -List =&gt; $list_info{list});</pre>
<p>this will make a HTML table that has the previous message, the index and the next message 
like this:</p>
<p>&lt;&lt; My Previous Message    |Archive Index|      My Next Message</p>
<p>
</p>
<h2><a name="make_search_form">make_search_form</a></h2>
<pre>
        print $archive -&gt; make_search_form();</pre>
<p>this prints out the correct HTML form to make for your archives.</p>
<p>
</p>
<h2><a name="_zap_sig_plaintext">_zap_sig_plaintext</a></h2>
<p><em>(Private Method)</em></p>
<pre>
 my $msg = $self-&gt;_zap_sig_plaintext($msg);</pre>
<p>Given a string, $msg, returns the message without the opening or signature.</p>
<p>In a PlainText message, the opening is terminated using the (Dada Mail specific):</p>
<p>__</p>
<p>Which is:</p>
<pre>
 [newline][underscore][underscore][space][newline]</pre>
<p>The signature is begun with:</p>
<p>--</p>
<p>Which is:</p>
<pre>
 [newline][dash][dash][space][newline]</pre>
<p>
</p>
<h2><a name="_zap_sig_html">_zap_sig_html</a></h2>
<p><em>(Private Method)</em></p>
<pre>
 $msg = $self-&gt;_zap_sig_html($msg);</pre>
<p>Given a string $msg, returns a string that does not have the information 
located between the opening and signature comments.</p>
<p>The opening comments look like this:</p>
<pre>
 &lt;!--opening--&gt;
 &lt;!--/opening--&gt;</pre>
<p>The signature comments look like this:</p>
<pre>
 &lt;!--signature--&gt;
 &lt;!--/signature--&gt;</pre>
<p>These are both very Dada Mail-specific.</p>
<p>
</p>
<h2><a name="massage">massage</a></h2>
<p>
</p>
<h2><a name="make_search_summary">make_search_summary</a></h2>
<pre>
 my $summaries = $archive-&gt;make_search_summary($keyword, $search_results);</pre>
<p>Given a $keyword (string) and $search_results (array ref of archive keys/ids) 
will return a hashref of each line the keyword appears in.</p>
<p>
</p>
<h2><a name="_faked_oldstyle_message">_faked_oldstyle_message</a></h2>
<p><em>Private Method</em></p>
<pre>
 ($new_message, $new_format) = $self-&gt;_faked_oldstyle_message($raw_msg);</pre>
<p><strong>background:</strong></p>
<p>Before version 2.9, Dada Mail did not save the complete email message, including
the headers, in its archive. Beginning with 2.9, if you're using one of the SQL 
backends, it will - but for backwards compatability, the old style, message-only
sort of method is still used.</p>
<p>
</p>
<h2><a name="message_blurb">message_blurb</a></h2>
<pre>
 print $archives-&gt;message_blurb(-key  =&gt; $key,
                                -size =&gt; 256, 
                               ),</pre>
<p>Given a key/id of an archived message, returns a plaintext snippet of 
the archived message. -size will change who large the archive blurb is. <strong>NOTE:</strong> 
that this is the maximum size. If the message is smaller, the blurb will reflect 
that.</p>
<p>
</p>
<h2><a name="massage_msg_for_resending">massage_msg_for_resending</a></h2>
<pre>
 print $archive-&gt;massage_msg_for_resending(-key =&gt; $entry),</pre>
<p>given a -key - a key/id of an archived message, will return a copy of that 
archived message formatted to be resent. Basically, this means that the email 
message template has been stripped from the saved message.</p>
<p>
</p>
<h2><a name="_take_off_sigs">_take_off_sigs</a></h2>
<pre>
 $entity = $self-&gt;_take_off_sigs($entity);</pre>
<p>($entity is a MIME::Entity object)</p>
<p>Returns a copy of the entity without the email message template 
apply (attempts to, anyways)</p>
<p>
</p>
<h2><a name="massaged_msg_for_display">massaged_msg_for_display</a></h2>
<pre>
 $message = $self-&gt;massaged_msg_for_display(-key =&gt; $key);</pre>
<p>returns a string, given a -key - an id/key of an archived message.</p>
<p>Can have many paramaters passed to it:</p>
<ul>
<li><strong><a name="item__2dplain_text">-plain_text</a></strong>

<p>will give back a plaintext formatted message.</p>
</li>
<li><strong><a name="item__2dbody_only">-body_only</a></strong>

<p>Will return a message formatted in HTML, but will not be a complete HTML 
document.</p>
</li>
</ul>
<p>
</p>
<h2><a name="_chomp_off_body">_chomp_off_body</a></h2>
<p><em>Private Method</em></p>
<pre>
 $body = $self-&gt;_chomp_off_body($body);</pre>
<p>Give a string, will return the contents of the string that were found 
between HTML &lt;body&gt; tags. If no content was found, will return the 
entire string back, unchanged.</p>
<p>
</p>
<h2><a name="_add_a_body_if_needed">_add_a_body_if_needed</a></h2>
<p><em>Private Method</em></p>
<pre>
 $body = $self-&gt;_add_a_body_if_needed($body)</pre>
<p>Given a string, looks if the string is a complete HTML document, and, if 
it's not, wraps one around it.</p>
<p>Used for showing archived messages.</p>
<p>
</p>
<h2><a name="_get_body_entity">_get_body_entity</a></h2>
<p><em>Private Methid</em></p>
<pre>
 $entity = $self-&gt;_get_body_entity($entity);</pre>
<p>Given an entity, attempts to find the main message - will default to HTML for
multipart/alternative messages.</p>
<p>
</p>
<h2><a name="_bs_raw_msg">_bs_raw_msg</a></h2>
<pre>
 $raw_msg = $self-&gt;_bs_raw_msg($subject, $message, $format);</pre>
<p>Tries to munge a complete MIME-compliant message, given a Subject, the body 
of a message and a format (text/plain, text/html)</p>
<p>
</p>
<h2><a name="w3cdtf">W3CDTF</a></h2>
<pre>
 print $self-&gt;W3CDTF($key);</pre>
<p>Given a key/id of an archived message, which is created from the date the message 
was sent, returns a string in the W3CDTF format.</p>
<p>More information:</p>
<p><a href="http://www.w3.org/TR/NOTE-datetime">http://www.w3.org/TR/NOTE-datetime</a></p>
<p>This is used for the Atom Feed.</p>
<p>
</p>
<h2><a name="atom_index">atom_index</a></h2>
<pre>
 print $archive-&gt;atom_index();</pre>
<p>returns a string representing the Atom Feed. More on Atom:</p>
<p><a href="http://www.atomenabled.org/">http://www.atomenabled.org/</a></p>
<p>See Also:</p>
<p><a href="http://search.cpan.org/~minter/XML-Atom-SimpleFeed-0.5/lib/XML/Atom/SimpleFeed.pm">http://search.cpan.org/~minter/XML-Atom-SimpleFeed-0.5/lib/XML/Atom/SimpleFeed.pm</a></p>
<p>
</p>
<h2><a name="rss_index">rss_index</a></h2>
<pre>
 print $archive-&gt;rss_index();</pre>
<p>returns a string representing the Rss Feed. More on Atom:</p>
<p>
</p>
<h2><a name="send_pings">send_pings</a></h2>
<pre>
 $self-&gt;send_pings();

</pre>
<p>Sends a notice to updating services, telling them that they should check out the 
new Syndication Feeds. More information: 

</p>
<p><a href="http://www.xmlrpc.com/weblogsCom">http://www.xmlrpc.com/weblogsCom</a>

</p>
<p>
</p>
<h2><a name="_massaged_key">_massaged_key</a></h2>
<p><em>Private Method</em> 

</p>
<p>Attempts to cleanse a key given to this object that contains weird things. Usually used to massage
the id created from the Message-ID header of a email message. 

</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright (c) 1999-2008 Justin Simoni All rights reserved. 

</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

</p>
<p>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, 
Boston, MA  02111-1307, USA.

</p>

</body>

</html>
